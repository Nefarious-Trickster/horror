<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Echo Census: Block 13</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; overflow:hidden; background:#020307; font-family: Inter, system-ui, sans-serif; color:#e8edf7; }
    #game { width:100vw; height:100vh; display:block; }
    .hud { position:fixed; inset:0; pointer-events:none; }
    .panel {
      position:fixed; left:12px; top:12px; width:min(390px, 88vw);
      background:rgba(8,12,20,.72); border:1px solid #33445f; border-radius:12px;
      padding:10px 12px; backdrop-filter: blur(2px);
    }
    .line { font-size:.9rem; margin:4px 0; }
    .help {
      position:fixed; right:12px; top:12px; width:min(360px,86vw);
      background:rgba(8,12,20,.62); border:1px solid #33445f; border-radius:12px; padding:10px 12px;
      font-size:.84rem;
    }
    .centerMsg {
      position:fixed; left:50%; bottom:8%; transform:translateX(-50%);
      background:rgba(3,6,11,.7); border:1px solid #33445f; border-radius:10px;
      padding:8px 12px; font-size:.95rem; text-shadow:0 0 8px #000;
    }
    .crosshair {
      position:fixed; left:50%; top:50%; width:10px; height:10px; margin:-5px 0 0 -5px;
      border:1px solid rgba(220,230,255,.52); border-radius:50%; box-shadow:0 0 8px rgba(180,210,255,.3);
    }
    #start {
      position:fixed; inset:0; display:grid; place-items:center; z-index:50;
      background:radial-gradient(circle at 50% 10%, rgba(36,44,64,.45), rgba(2,3,8,.95));
    }
    .card {
      width:min(820px,92vw); background:rgba(8,12,20,.9); border:1px solid #3e4e69; border-radius:12px;
      padding:18px;
    }
    .card button { pointer-events:auto; margin-top:12px; border:1px solid #4b6288; background:#1b2942; color:#eef4ff; border-radius:8px; padding:9px 14px; cursor:pointer; }
    #scareOverlay {
      position:fixed; inset:0; display:none; place-items:center; z-index:60;
      background:rgba(0,0,0,.76);
    }
    .scareFace {
      width:min(68vmin,640px); aspect-ratio:1/1; border-radius:50%;
      background:
        radial-gradient(circle at 35% 35%, #fff 0 4%, #5f0707 5% 8%, transparent 9%),
        radial-gradient(circle at 66% 35%, #fff 0 4%, #5f0707 5% 8%, transparent 9%),
        radial-gradient(circle at 50% 60%, #280101 0 11%, transparent 12%),
        radial-gradient(circle at 50% 50%, #be1212 0%, #350404 60%, #000 82%);
      box-shadow:0 0 180px rgba(200,15,15,.8);
      animation:shake .06s infinite alternate;
    }
    @keyframes shake { from { transform: translate(-3px,-2px) scale(1.01);} to{ transform: translate(3px,2px) scale(1);} }
    #vignette {
      position:fixed; inset:0; pointer-events:none;
      background:radial-gradient(circle at 50% 50%, transparent 40%, rgba(0,0,0,.55) 90%);
    }
  </style>
</head>
<body>
  <canvas id="game" width="1365" height="768"></canvas>
  <div id="vignette"></div>

  <section class="hud">
    <div class="panel">
      <div class="line"><strong>ECHO CENSUS — BLOCK 13</strong></div>
      <div class="line" id="obj"></div>
      <div class="line" id="phase"></div>
      <div class="line" id="noise"></div>
      <div class="line" id="records"></div>
      <div class="line" id="status"></div>
    </div>
    <div class="help">
      <div><strong>Controls</strong></div>
      <div>WASD move • Mouse look • E interact • Shift sprint</div>
      <div>Find fuse key, power generator, recover 3 red records, then extract at elevator.</div>
      <div>Noise and repetition raise suspicion. Suspicion raises dread. Dread summons events.</div>
    </div>
    <div class="crosshair"></div>
    <div class="centerMsg" id="msg"></div>
  </section>

  <section id="start">
    <div class="card">
      <h1>Echo Census: Block 13</h1>
      <p>This is a longer horror run with buildup phases, audio tension, and objective-gated progression.</p>
      <p>Start quiet. The building copies your habits. If the dread reaches Hunt phase, extraction becomes dangerous.</p>
      <button id="startBtn">Start Shift</button>
    </div>
  </section>

  <section id="scareOverlay"><div class="scareFace"></div></section>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const keys = new Set();

    const objEl = document.getElementById('obj');
    const phaseEl = document.getElementById('phase');
    const noiseEl = document.getElementById('noise');
    const recordsEl = document.getElementById('records');
    const statusEl = document.getElementById('status');
    const msgEl = document.getElementById('msg');
    const startEl = document.getElementById('start');
    const scareOverlay = document.getElementById('scareOverlay');
    const vignette = document.getElementById('vignette');

    const MAP = [
      '########################################',
      '#S....#...........#........N......#...#',
      '#.##..#.####.###..#.######.######.#.#.#',
      '#....##....#...#..#....#.........#.#..#',
      '####....##.###.#..####.#.#########.#.##',
      '#..#....#......#.....#.#....#......#..#',
      '#..#.####.##########.#.####.#.######..#',
      '#..#......#......#...#....#.#......#..#',
      '#..######.#.####.#.######.#.######.#..#',
      '#..#....#.#.#..#.#......#.#......#.#..#',
      '#..#.##.#.#.#..#.######.#.######.#.#..#',
      '#....##...#.#..#....R...#....#...#....#',
      '######.####.#.######.########.#.#######',
      '#....#.#....#....#....#.....#.#.......#',
      '#.##.#.#.####.##.#.##.#.###.#.#####.#.#',
      '#.#..#.#....#....#..#.#...#.#.....#.#.#',
      '#.#.##.####.########.#.###.#.###.#.#.#E',
      '#.#....#..#......#...#...#.#...#.#.#..#',
      '#.######..######.#.#####.#.###.#.#.##.#',
      '#...............G#.......#...#...#....#',
      '#.###############.#########.##########.#',
      '#..N.....R.........F.........R......N..#',
      '########################################'
    ];

    const WALL_THEME = {
      '#': { base:[70,84,108], accent:[95,108,130] }
    };

    const FOV = Math.PI / 3;
    const RAYS = 360;
    const MAX_DIST = 30;

    const game = {
      x:1.5, y:1.5, a:0,
      running:false,
      won:false,
      dead:false,
      message:'Enter Block 13.', messageTimer:4,
      dread:0, phase:0,
      suspicion:0,
      noisePulse:0,
      routeStreak:0,
      lastCell:'',
      eventCooldown:2,
      scareCount:0,
      notes:0,
      records:0,
      fuse:false,
      generator:false,
      spawn:{x:1.5,y:1.5}
    };

    const pickups = { records:[], notes:[], fuse:null, generator:null, elevator:null };

    function cellAt(x,y){
      const gx=Math.floor(x), gy=Math.floor(y);
      if (gy<0||gy>=MAP.length||gx<0||gx>=MAP[0].length) return '#';
      return MAP[gy][gx];
    }
    function isWall(x,y){ return cellAt(x,y)==='#'; }

    function setupMap(){
      for(let y=0;y<MAP.length;y++) for(let x=0;x<MAP[0].length;x++){
        const c=MAP[y][x];
        if(c==='S'){game.x=x+.5;game.y=y+.5;game.spawn={x:game.x,y:game.y};}
        if(c==='R') pickups.records.push({x:x+.5,y:y+.5,got:false});
        if(c==='N') pickups.notes.push({x:x+.5,y:y+.5,got:false,text:[
          'Memo: building responds strongest to repeated footwork patterns.',
          'Memo: do not sprint in lit corridors; it triangulates cadence.',
          'Memo: elevator remains sealed until generator + red archive records.'
        ][pickups.notes.length%3]});
        if(c==='F') pickups.fuse={x:x+.5,y:y+.5,got:false};
        if(c==='G') pickups.generator={x:x+.5,y:y+.5,on:false};
        if(c==='E') pickups.elevator={x:x+.5,y:y+.5};
      }
    }
    setupMap();

    // Audio engine (generated, no assets)
    let audioCtx, master, droneGain, pulseGain;
    function initAudio(){
      if(audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      master = audioCtx.createGain(); master.gain.value = 0.22; master.connect(audioCtx.destination);

      const drone = audioCtx.createOscillator();
      drone.type='sawtooth'; drone.frequency.value=47;
      droneGain = audioCtx.createGain(); droneGain.gain.value = 0.04;
      drone.connect(droneGain).connect(master); drone.start();

      const pulse = audioCtx.createOscillator();
      pulse.type='triangle'; pulse.frequency.value=1.4;
      pulseGain = audioCtx.createGain(); pulseGain.gain.value = 0.0;
      pulse.connect(pulseGain).connect(master); pulse.start();

      // periodic creak/noise bursts
      setInterval(()=>{
        if(!game.running || game.dead || game.won) return;
        if(Math.random() < 0.18 + game.phase*0.1){
          const noise = audioCtx.createBufferSource();
          const len = 0.18;
          const buf = audioCtx.createBuffer(1, audioCtx.sampleRate*len, audioCtx.sampleRate);
          const data = buf.getChannelData(0);
          for(let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * Math.exp(-i/(data.length*0.26));
          noise.buffer = buf;
          const g = audioCtx.createGain();
          g.gain.value = 0.015 + game.phase*0.01;
          noise.connect(g).connect(master);
          noise.start();
        }
      }, 1450);
    }

    function footstepSound(speed=1){
      if(!audioCtx) return;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type='square';
      o.frequency.value = 90 + Math.random()*35;
      g.gain.setValueAtTime(0.0001, audioCtx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.015*speed, audioCtx.currentTime+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+0.08);
      o.connect(g).connect(master);
      o.start(); o.stop(audioCtx.currentTime+0.09);
    }

    function scareSound(){
      if(!audioCtx) return;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type='sawtooth'; o.frequency.setValueAtTime(220, audioCtx.currentTime);
      o.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime+0.4);
      g.gain.setValueAtTime(0.0001, audioCtx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.2, audioCtx.currentTime+0.03);
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+0.45);
      o.connect(g).connect(master); o.start(); o.stop(audioCtx.currentTime+0.46);
    }

    function castRay(angle){
      const si=Math.sin(angle), co=Math.cos(angle);
      for(let d=0; d<MAX_DIST; d+=0.025){
        const x=game.x+co*d, y=game.y+si*d;
        if(isWall(x,y)) return {d,x,y};
      }
      return {d:MAX_DIST,x:game.x+co*MAX_DIST,y:game.y+si*MAX_DIST};
    }

    function textureShade(hit, dist){
      const fx = hit.x - Math.floor(hit.x);
      const fy = hit.y - Math.floor(hit.y);
      const seam = Math.abs(fx-0.5) < Math.abs(fy-0.5) ? fx : fy;
      const stripe = Math.sin(seam * Math.PI * 22) * 0.12;
      const grime = Math.sin((hit.x*2.1 + hit.y*1.7) * 4.2) * 0.08;
      const base = Math.max(0.14, 1 - dist / 17);
      return Math.max(0.08, base + stripe + grime);
    }

    function drawWorld(){
      const w=canvas.width, h=canvas.height;
      const flick = 0.9 + Math.sin(performance.now()*0.003 + game.phase)*0.08;
      const ceil = [12*flick, 16*flick, 24*flick];
      const floor = [9*flick, 8*flick, 10*flick];
      ctx.fillStyle=`rgb(${ceil[0]},${ceil[1]},${ceil[2]})`; ctx.fillRect(0,0,w,h/2);
      ctx.fillStyle=`rgb(${floor[0]},${floor[1]},${floor[2]})`; ctx.fillRect(0,h/2,w,h/2);

      for(let i=0;i<RAYS;i++){
        const t=i/RAYS;
        const ra = game.a - FOV/2 + t*FOV;
        const hit = castRay(ra);
        const corrected = hit.d*Math.cos(ra-game.a);
        const wallH = Math.min(h, (h/Math.max(0.0001,corrected))*0.87);
        const x=i*(w/RAYS), y=h/2-wallH/2;

        const shade = textureShade(hit, corrected);
        const [r,g,b] = WALL_THEME['#'].base;
        ctx.fillStyle = `rgb(${r*shade},${g*shade},${b*shade})`;
        ctx.fillRect(x,y,Math.ceil(w/RAYS)+1,wallH);

        // vertical grime lines
        if((i%14)===0){
          ctx.fillStyle=`rgba(20,25,34,${0.12+0.18*(1-shade)})`;
          ctx.fillRect(x,y,1,wallH);
        }
      }

      drawSpriteSet(pickups.records.filter(r=>!r.got), 'record');
      drawSpriteSet(pickups.notes.filter(n=>!n.got), 'note');
      if(pickups.fuse && !pickups.fuse.got) drawSpriteSet([pickups.fuse], 'fuse');
      if(pickups.generator && !pickups.generator.on) drawSpriteSet([pickups.generator], 'gen-off');
      if(pickups.generator && pickups.generator.on) drawSpriteSet([pickups.generator], 'gen-on');
      drawSpriteSet([pickups.elevator], game.records>=3 && game.generator ? 'elev-on' : 'elev-off');

      const v = 0.55 + game.phase*0.07 + game.dread*0.002;
      vignette.style.background = `radial-gradient(circle at 50% 50%, transparent 40%, rgba(0,0,0,${Math.min(0.86,v)}) 90%)`;
    }

    function drawSpriteSet(items, type){
      const w=canvas.width, h=canvas.height;
      for(const s of items){
        const dx=s.x-game.x, dy=s.y-game.y;
        const dist=Math.hypot(dx,dy);
        let ang=Math.atan2(dy,dx)-game.a;
        while(ang>Math.PI) ang-=Math.PI*2;
        while(ang<-Math.PI) ang+=Math.PI*2;
        if(Math.abs(ang)>FOV/1.8) continue;

        const wall=castRay(game.a+ang);
        if(wall.d<dist) continue;

        const size=(h/Math.max(0.35,dist))*0.24;
        const sx=(ang/(FOV/2))*(w/2)+w/2-size/2;
        const sy=h/2-size/2;

        if(type==='record'){
          ctx.fillStyle='#6b0e16'; ctx.fillRect(sx,sy,size*0.85,size);
          ctx.fillStyle='#f3e9dd'; ctx.fillRect(sx+size*0.1,sy+size*0.18,size*0.65,size*0.08);
          ctx.fillRect(sx+size*0.1,sy+size*0.33,size*0.55,size*0.08);
        }else if(type==='note'){
          ctx.fillStyle='#b7c9ff'; ctx.fillRect(sx,sy,size*0.8,size*0.95);
          ctx.fillStyle='rgba(70,84,125,.6)'; ctx.fillRect(sx+size*0.08, sy+size*0.18, size*0.62, size*0.07);
        }else if(type==='fuse'){
          ctx.fillStyle='#f8c86b'; ctx.beginPath(); ctx.arc(sx+size/2, sy+size/2, size*0.38, 0, Math.PI*2); ctx.fill();
          ctx.fillStyle='#7b5312'; ctx.fillRect(sx+size*0.3,sy+size*0.2,size*0.4,size*0.6);
        }else if(type==='gen-off' || type==='gen-on'){
          ctx.fillStyle= type==='gen-on' ? '#60ff98' : '#54706a';
          ctx.fillRect(sx,sy,size,size*0.9);
          ctx.fillStyle= type==='gen-on' ? 'rgba(160,255,190,.7)' : 'rgba(20,30,28,.6)';
          ctx.fillRect(sx+size*0.2,sy+size*0.2,size*0.6,size*0.5);
        }else if(type==='elev-on' || type==='elev-off'){
          ctx.fillStyle= type==='elev-on' ? '#c982ff' : '#544d68';
          ctx.fillRect(sx,sy,size*0.95,size*1.2);
          ctx.fillStyle='rgba(230,240,255,.35)'; ctx.fillRect(sx+size*0.15,sy+size*0.2,size*0.65,size*0.2);
        }
      }
    }

    function canMove(nx,ny){
      const p=.16;
      return !isWall(nx-p,ny-p)&&!isWall(nx+p,ny-p)&&!isWall(nx-p,ny+p)&&!isWall(nx+p,ny+p);
    }

    function setMsg(t,s=1.8){ game.message=t; game.messageTimer=s; }

    function runScare(label='Unknown signal', dur=520){
      scareOverlay.style.display='grid';
      scareSound();
      game.scareCount++;
      game.dread = Math.min(100, game.dread + 12);
      setMsg(label, 2.5);
      setTimeout(()=> scareOverlay.style.display='none', dur);
    }

    function interact(){
      if(game.dead||game.won) return;
      const near=(p,d=1.1)=>Math.hypot(p.x-game.x,p.y-game.y)<d;

      const rec = pickups.records.find(r=>!r.got&&near(r));
      if(rec){ rec.got=true; game.records++; setMsg('Red archive recovered.',1.8); return; }

      const note = pickups.notes.find(n=>!n.got&&near(n));
      if(note){ note.got=true; game.notes++; setMsg(note.text,4.5); return; }

      if(pickups.fuse && !pickups.fuse.got && near(pickups.fuse)){
        pickups.fuse.got=true; game.fuse=true; setMsg('Fuse key acquired. Generator can now be started.',2.8); return;
      }

      if(pickups.generator && near(pickups.generator,1.25)){
        if(!game.fuse){ setMsg('Generator locked: fuse key required.',1.8); return; }
        if(!pickups.generator.on){
          pickups.generator.on=true; game.generator=true;
          setMsg('Generator online. The building woke up.',2.6);
          game.dread = Math.min(100, game.dread + 16);
          runScare('Power hum harmonizes with your breathing.', 420);
          return;
        }
      }

      if(pickups.elevator && near(pickups.elevator,1.2)){
        if(game.records<3){ setMsg(`Elevator denied: ${3-game.records} records missing.`,1.6); return; }
        if(!game.generator){ setMsg('Elevator offline: generator not active.',1.6); return; }
        game.won=true; setMsg('Extraction complete. City system retained your profile.',999);
        return;
      }

      setMsg('Nothing useful here.',1);
    }

    function update(dt){
      if(!game.running || game.dead || game.won) return;

      game.eventCooldown = Math.max(0, game.eventCooldown-dt);
      game.messageTimer = Math.max(0, game.messageTimer-dt);

      let moved=false;
      const speed=(keys.has('shift')?2.9:2.05)*dt;
      let nx=game.x, ny=game.y;

      if(keys.has('w')){ nx+=Math.cos(game.a)*speed; ny+=Math.sin(game.a)*speed; moved=true; }
      if(keys.has('s')){ nx-=Math.cos(game.a)*speed; ny-=Math.sin(game.a)*speed; moved=true; }
      if(keys.has('a')){ nx+=Math.cos(game.a-Math.PI/2)*speed; ny+=Math.sin(game.a-Math.PI/2)*speed; moved=true; }
      if(keys.has('d')){ nx+=Math.cos(game.a+Math.PI/2)*speed; ny+=Math.sin(game.a+Math.PI/2)*speed; moved=true; }

      if(canMove(nx,game.y)) game.x=nx;
      if(canMove(game.x,ny)) game.y=ny;

      const cell=`${Math.floor(game.x)},${Math.floor(game.y)}`;
      if(cell===game.lastCell) game.routeStreak=Math.min(30,game.routeStreak+dt);
      else game.routeStreak=Math.max(0,game.routeStreak-dt*1.4);
      game.lastCell=cell;

      // suspense model: not instant jumpscare, builds through phases
      const noiseAdd = moved ? (keys.has('shift') ? 0.9 : 0.35) : -0.25;
      game.noisePulse = Math.max(0, Math.min(100, game.noisePulse + noiseAdd * dt * 9));

      let dreadDelta = 0;
      dreadDelta += moved ? 0.8*dt : -0.35*dt;
      dreadDelta += game.routeStreak * 0.006 * dt;
      dreadDelta += game.noisePulse * 0.002 * dt;
      dreadDelta += game.generator ? 0.35*dt : 0;
      game.dread = Math.max(0, Math.min(100, game.dread + dreadDelta));

      // suspicion ties to movement behavior; phase increases with dread milestones
      game.suspicion = Math.max(0, Math.min(100, game.suspicion + (moved?0.6:-0.4)*dt*8 + game.routeStreak*0.03*dt));
      const prevPhase=game.phase;
      if(game.dread<20) game.phase=0;
      else if(game.dread<45) game.phase=1;
      else if(game.dread<72) game.phase=2;
      else game.phase=3;
      if(game.phase!==prevPhase){
        const names=['Quiet', 'Unease', 'Manifest', 'Hunt'];
        setMsg(`Phase shift: ${names[game.phase]}.`, 2.2);
      }

      if(moved && Math.random() < 0.06*dt*60) footstepSound(keys.has('shift')?1.4:1);

      // audio modulation by phase
      if(droneGain){
        droneGain.gain.value = 0.03 + game.phase*0.015 + game.dread*0.0007;
        pulseGain.gain.value = 0.003 + game.phase*0.01;
      }

      // suspense events first, jumpscare mostly in higher phases
      if(game.eventCooldown<=0){
        if(game.phase===1 && Math.random()<0.06){ setMsg('Distant elevator chime from a non-existent floor.',2.8); game.eventCooldown=3; }
        else if(game.phase===2 && Math.random()<0.1){ setMsg('Your own footsteps replay one corridor ahead.',2.6); game.eventCooldown=2.6; }
        else if(game.phase===3 && Math.random()<0.24){ runScare('Contact event: echo breach.', 420 + Math.random()*220); game.eventCooldown=2.2; }
      }

      // position-based beats
      if(game.x>30 && game.y<8 && game.phase>=2 && !game.zoneA){ game.zoneA=true; setMsg('You hear someone whisper your route choices.',3); }
      if(game.x<8 && game.y>17 && game.phase>=2 && !game.zoneB){ game.zoneB=true; runScare('Mirror-contact in service wing.', 540); }

      // fail in hunt if too loud too long
      if(game.phase===3 && game.noisePulse>78 && game.suspicion>80){
        game.dead=true;
        runScare('The Echo found you first.', 900);
        setMsg('REPORT STATUS: replaced.',999);
      }
    }

    function renderUI(){
      objEl.textContent = `Objective: fuse ${game.fuse?'✓':'✗'} • generator ${game.generator?'✓':'✗'} • records ${game.records}/3 • elevator`;
      phaseEl.textContent = `Buildup phase: ${['Quiet','Unease','Manifest','Hunt'][game.phase]} • dread ${Math.floor(game.dread)}%`;
      noiseEl.textContent = `Noise: ${Math.floor(game.noisePulse)} • suspicion: ${Math.floor(game.suspicion)}`;
      recordsEl.textContent = `Notes: ${game.notes}/${pickups.notes.length} • scares survived: ${game.scareCount}`;
      statusEl.textContent = game.won ? 'Status: Extracted' : game.dead ? 'Status: Replaced' : 'Status: In shift';
      msgEl.textContent = (game.messageTimer>0 || game.won || game.dead) ? game.message : '';
    }

    let last=performance.now();
    function loop(now){
      const dt=Math.min(0.033,(now-last)/1000); last=now;
      update(dt); drawWorld(); renderUI();
      requestAnimationFrame(loop);
    }

    document.addEventListener('keydown', e=>{
      const k=e.key.toLowerCase();
      if(k==='e') interact();
      keys.add(k);
      if(['arrowleft','arrowright','arrowup','arrowdown',' '].includes(k)) e.preventDefault();
    });
    document.addEventListener('keyup', e=> keys.delete(e.key.toLowerCase()));

    document.addEventListener('mousemove', e=>{
      if(document.pointerLockElement===canvas && game.running && !game.dead && !game.won) game.a += e.movementX*0.0025;
    });

    document.getElementById('startBtn').onclick = async ()=>{
      initAudio();
      if(audioCtx && audioCtx.state==='suspended') await audioCtx.resume();
      game.running=true;
      startEl.style.display='none';
      canvas.requestPointerLock();
      setMsg('Shift start. Keep moving, but don\'t repeat yourself.',3);
    };

    canvas.addEventListener('click', ()=>{
      if(game.running && document.pointerLockElement!==canvas && !game.dead && !game.won) canvas.requestPointerLock();
    });

    requestAnimationFrame(loop);
  </script>
</body>
</html>
